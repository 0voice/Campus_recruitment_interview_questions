## 面试题

> 无法跳转到题目请在右侧目录索引中输入对应题目的序号点击即可

## 1. 1000个 goroutine 进行 IO 处理会发生什么？

* Go 的 goroutine 非常轻量，1000 个并发 goroutine 不成问题。
* IO 操作会导致 goroutine 阻塞，但 Go runtime 会自动调度其他 goroutine 继续执行。
* 1000 个 goroutine 进行 IO，整体不会阻塞系统，但具体性能依赖于 IO 资源和调度效率。


## 2. 携程在哪些情况下会被剥离 M？

* Go runtime 的调度模型是 G（goroutine）-M（OS线程）-P（调度器）。
* 当 goroutine 需要系统调用（syscall）或阻塞操作时，M 可能被剥离，让其他 M 继续执行其他 goroutine。
* M 剥离防止阻塞 OS 线程，保证调度高效。

## 3. 网络设计模式？

* 常见网络设计模式有：

  * Reactor 模式（事件驱动）
  * Proactor 模式（异步操作）
  * 半同步半异步模式（异步处理请求，同步业务逻辑）
  * 多线程/多进程模型
* 这些模式用于高效处理大量并发连接和请求。

## 4. 学习中的难点？

* 可能因人而异，常见难点包括：

  * 理解并发与并行
  * 理解底层原理（内存模型、网络协议）
  * 实践与理论结合
  * 调试复杂系统
  * 设计高可用高性能系统

## 5. GPM 调度器？

* Go runtime 的调度模型是 G（goroutine）-P（处理器）-M（操作系统线程）。
* P 是调度上下文，管理 M 的执行和 G 的分配。
* 调度器负责让 G 在 M 上执行，利用 P 做资源调度。
* 这种设计提高并发性能和可扩展性。

## 6. 执行系统调用的整个过程？

* 应用程序调用库函数（如 `read`、`write`）。
* 库函数通过软中断触发进入内核态。
* 内核检查参数，调度具体驱动或服务处理请求。
* 内核返回结果，软中断返回用户态。
* 应用继续执行。

## 7. 乐观锁和悲观锁？

* **悲观锁**：假设会有冲突，执行时加锁，防止并发修改，适合冲突多的场景。
* **乐观锁**：假设冲突少，不加锁，执行时通过版本号或时间戳检测冲突，冲突时重试，适合读多写少场景。

## 8. 数据库中的乐观锁是如何实现的？

* 通过版本号（version）或时间戳字段实现。
* 读数据时获取版本号，更新时带上版本号条件。
* 如果更新时版本号不匹配，说明数据被修改，操作失败或重试。

## 9. 消息队列异步削峰

* 将高峰流量请求异步写入消息队列。
* 后端消费者按速率处理，平滑峰值压力。
* 减少系统瞬时压力，避免服务崩溃。

## 10. 用户取消订单如何处理？

* 业务上先修改订单状态为“取消”。
* 回滚库存和支付（退款）。
* 若使用消息队列，发送取消消息通知其他服务。
* 保证数据一致性和幂等。

## 11. 索引的数据结构 B+树特点

* 多路平衡树，所有值都存在叶子节点。
* 叶子节点通过链表连接，方便范围查询。
* 内部节点只存键和指针，减少树高度。
* 适合磁盘存储，IO 效率高。

## 12. 数据库四个隔离级别

* **读未提交（Read Uncommitted）**：允许脏读。
* **读已提交（Read Committed）**：禁止脏读，允许不可重复读。
* **可重复读（Repeatable Read）**：禁止脏读和不可重复读，允许幻读（MySQL默认）。
* **串行化（Serializable）**：最高隔离级别，禁止所有并发异常。

## 13. 幻读

* 事务中两次查询结果不一致，因其他事务插入了新数据。
* 是一种并发异常现象。

## 14. 间隙锁

* 锁定索引间的“间隙”，防止幻读。
* 用于防止其他事务在锁定区间插入新记录。

## 15. 写锁

* 独占锁，阻止其他事务读写同一数据。
* 确保数据写操作的原子性和一致性。

## 16. Setnx 实现分布式锁

* Redis 的 SETNX 命令只在 key 不存在时设置成功。
* 通过设置过期时间防止死锁。
* 竞争资源时，只有一个客户端获得锁。

## 17. Redis 缓存三兄弟

* **缓存穿透**：请求查询不存在数据，穿透到数据库。
* **缓存击穿**：热点数据失效，瞬时大量请求到数据库。
* **缓存雪崩**：大量缓存同时过期，数据库压力骤增。

## 18. Zset 设计每日分数排行榜

* 使用 Redis Zset（有序集合）存储用户与分数。
* 分数作为排序权重，支持快速排名查询。
* 定期清理历史数据，支持实时排行榜。


## 19. 死锁如何解决？

* 避免死锁：按固定顺序加锁，减少锁粒度。
* 使用超时机制，检测和回滚死锁事务。
* 数据库自动检测死锁并回滚其中一个事务。


## 20. URL 映射

* 将长 URL 映射成短 URL。
* 常用哈希算法或自增 ID 转短码。
* 支持反向映射，实现跳转。


## 21. Spring 里面的 IoC 了解吗？

* IoC（控制反转）指由框架负责创建和管理对象，而不是程序主动创建。
* Spring 通过依赖注入（DI）实现 IoC，解耦组件，方便管理和测试。

## 22. 常用注解？

* `@Component`、`@Service`、`@Repository`、`@Controller`：标注不同层的 Bean。
* `@Autowired`：自动注入依赖。
* `@Configuration`、`@Bean`：配置类和方法。
* `@RequestMapping`：请求映射。
* `@Transactional`：事务管理。


## 23. 注解的原理知道吗？

* 注解是 Java 的元数据，存在于类文件中。
* 通过反射机制读取注解信息。
* 运行时，框架根据注解执行对应逻辑。



## 24. Java 的 HashMap 底层数据结构？

* 数组 + 链表（Java 8 以后，链表在一定长度会转为红黑树）。
* 通过 key 的 hashCode 定位数组索引，解决冲突用链表或红黑树。

## 25. 为什么链表要转换成红黑树？

* 当链表长度过长（默认 8），为了避免链表查找时间变长，转换成红黑树，保证查找效率从 O(n) 降到 O(log n)。


## 26. HashMap 是无序的吧？

* 是的，HashMap 不保证元素顺序。

## 27. 要想有序，用哪个 Map？

* `LinkedHashMap`：保持插入顺序。
* `TreeMap`：根据键的自然顺序或 Comparator 排序。


## 28. MySQL 的事务特性？

* 原子性、隔离性、一致性、持久性（ACID）。
* 保证事务操作的完整和数据正确。

## 29. 隔离级别，和默认隔离级别？

* 四个隔离级别：读未提交、读已提交、可重复读、串行化。
* MySQL 默认是 **可重复读**，防止脏读和不可重复读，但允许幻读。


## 30. 线程池了解吗？

* 线程池复用线程，避免频繁创建销毁。
* 核心参数：核心线程数、最大线程数、任务队列、拒绝策略。
* 线程池提高系统吞吐量和资源利用率。


## 31. 两个机器通过网线连接，一个是1.1.1.1，另一个是2.2.2.2，可以进行数据包的发送吗？

* 不一定能直接通信，取决于两台机器的子网掩码是否一致。
* 如果不在同一网段，需要路由器或三层设备转发。
* 直接连接且无配置路由，且IP不在同一网段，数据包会发送失败。



## 32. IP层分片机制是怎么实现的？

* 当数据包超过链路最大传输单元（MTU）时，IP层将包分成多个片段。
* 每个分片带有偏移量和标识符，接收端根据这些信息重组数据包。
* 分片由发送端IP完成，重组由接收端IP完成。


## 33. TCP报文中的选项设置？

* 常见选项包括：

  * 最大报文段长度（MSS）
  * 窗口缩放（Window Scaling）
  * 时间戳（Timestamp）
  * 选择确认（SACK）


## 34. 时间戳机制？

* 用于测量往返时间（RTT）和防止序列号回绕。
* TCP选项中的时间戳字段带有发送时间戳和回显时间戳。


## 35. 序列号的随机生成？

* 连接建立时，初始序列号由双方随机生成，提高安全性，防止序列号预测攻击。


## 36. TCP端口复用机制？

* 多个连接可复用相同本地端口，但四元组（源IP，源端口，目的IP，目的端口）必须唯一。
* 这样可以区分不同连接。

## 37. 接收窗口满了怎么处理？

* 接收端会发送窗口大小为0的确认，通知发送端暂停发送数据。
* 等缓冲区有空余后，接收端会通知窗口恢复。


## 38. 四次挥手？

* TCP连接关闭是全双工的，双方需要各自关闭发送通道。
* 四次挥手步骤：

  1. 主动关闭方发送 FIN。
  2. 对方确认 ACK。
  3. 对方发送 FIN。
  4. 主动关闭方确认 ACK。


## 39. ARP协议？

* 地址解析协议，用于根据 IP 地址查找对应的 MAC 地址。
* 工作在局域网内，发送 ARP 请求广播询问 MAC，收到回复后缓存。

## 40. commonjs 和 esmodule 区别？

* CommonJS 是同步加载、运行时模块，适合 Node.js；
* ESModule 是静态编译、支持异步加载，适合现代浏览器和前端开发。

## 41. 事件过程

* 事件分为三个阶段：捕获阶段、目标阶段、冒泡阶段。
* 事件从 window 到目标元素捕获，再从目标元素冒泡回 window。


## 42. 阻止冒泡

* 使用 `event.stopPropagation()` 可以阻止事件继续冒泡。


## 43. 盒模型

* 内容(content)、内边距(padding)、边框(border)、外边距(margin)组成元素盒子。

## 44. BFC 和触发方法

* BFC（块格式化上下文）是一个独立的布局环境，避免外边距重叠，控制浮动元素。
* 触发 BFC 的方法：

  * `display: flow-root`
  * `overflow: hidden`/`auto`
  * `position: absolute/fixed`
  * `float` 属性非 none

## 45. 实现动画的几种方式

* CSS 动画（`transition`、`animation`）
* JavaScript 定时器（`setTimeout`/`setInterval`）
* `requestAnimationFrame`

## 46. requestAnimationFrame 实现动画优点

* 与浏览器刷新频率同步，性能好，节省资源。
* 避免回流和重绘次数过多。
* 页面隐藏时自动暂停，节省 CPU。

## 47. flex: 1 含义

* `flex: 1` 是 `flex-grow: 1; flex-shrink: 1; flex-basis: 0;` 的简写。
* 表示元素可增长和缩小，基础尺寸为0，占据剩余空间。

## 48. flex-shrink 和 flex-grow

* `flex-grow` 控制元素放大比例。
* `flex-shrink` 控制元素缩小比例。

## 49. 内容溢出写法

* `overflow: visible | hidden | scroll | auto` 控制内容溢出时的表现。

## 50. TypeScript 泛型

* 泛型是让函数或类支持多种数据类型，提高复用性。
* 通过 `<T>` 形式声明泛型。

## 51. extends 关键字

* 用于类继承父类。
* 泛型中 `extends` 用来约束类型范围。

